<!DOCTYPE html>

<html lang="en">

<head>

  <meta charset="UTF-8">

  <title>Image/GIF to SSD1327 4bpp C Array Exporter</title>

  <style>

    body { background:#232323; color:#eee; font-family:sans-serif; }

    h1 { font-size:1.3em; }

    label {display:inline-block; width:9em;}

    #oledPreview { background:#222; border:2px solid #111; }

    textarea { width:99%; height:15em; font-family:monospace; margin-top:.7em;}

    #frameSel { font-size:80%; }

    .tiny { font-size:.8em; opacity:0.7; }

    .controls { margin-top:.8em; }

    button { margin:.1em .25em;}

  </style>

</head>

<body>

  <h1>Image/GIF to SSD1327 4bpp C Array Exporter</h1>

  <label>Upload image/GIF:</label>

  <input type="file" id="imgLoader" accept="image/*"><br>

  <label>Variable name:</label>

  <input type="text" id="cVarName" value="oled_img" style="width:10em;"><br>

  <label>W × H (px):</label>

  <input type="number" id="oledW" value="128" style="width:3em;">

  x <input type="number" id="oledH" value="128" style="width:3em;"><br>

  <label>Brightness γ:</label>

  <input type="range" id="gamma" min="70" max="160" value="100"> (<span id="gammaval">1.00</span>)<br>

  <label>Grayscale mode:</label>

  <select id="grayscaleMode" style="width:12em;">

    <option value="yellow" selected>Yellow channel only</option>

    <option value="luminance">Standard luminance</option>

  </select>

  <div class="controls">

    <span id="frameSel"></span>

  </div>

  <canvas id="oledPreview" width="128" height="128"></canvas>

  <div>

    <button id="toCbtn">Export C</button>

  </div>

  <textarea id="cout" readonly placeholder="C output will appear here..."></textarea>

  <div class="tiny">

    <b>How it works:</b><br>

    - Upload PNG/JPG/BMP for single frame, or GIF for animation<br>

    - Animated GIF is supported via omggif (all frames extracted in browser!)<br>

    - W × H auto-fills to image/GIF size; change values to resize/crop (resampling/stretch).<br>

    - "Variable name" sets the exported C array name.<br>

    - "Yellow channel only" uses min(R,G) for yellow OLED optimization; "Standard luminance" uses Y=0.299R+0.587G+0.114B.<br>

    - Each frame: <code>[height][width/2]</code> packed (16 grayscale, 2 px per byte).<br>

  </div>

<script src="https://cdn.jsdelivr.net/npm/omggif@1.0.10/omggif.min.js"></script>

<script>

let frames = []; // Each frame: {img: ImageData, dur: int} (dur ms, unused here)

let curFrame = 0;

const canvas = document.getElementById('oledPreview');

const ctx = canvas.getContext('2d');

let outW = 128, outH = 128;



document.getElementById('oledW').oninput =

document.getElementById('oledH').oninput =

  function() {

    outW = parseInt(document.getElementById('oledW').value|0);

    outH = parseInt(document.getElementById('oledH').value|0);

    canvas.width = outW; canvas.height = outH;

    previewFrame();

  };



document.getElementById('gamma').oninput = function() {

  let g = document.getElementById('gamma').value;

  document.getElementById('gammaval').textContent = (g/100).toFixed(2);

  previewFrame();

};



document.getElementById('grayscaleMode').onchange = function() {

  previewFrame();

};



function showFrameSel() {

  let el = document.getElementById('frameSel');

  if (frames.length<=1) { el.innerHTML = ""; return; }

  let out = "";

  for(let i=0;i<frames.length;++i)

    out+=`<button onclick="curFrame=${i};previewFrame()" style="font-weight:${curFrame==i?'bold':'normal'};">${i+1}</button> `;

  el.innerHTML = "Frame: "+out;

}



function calculateGrayscale(r, g, b, mode) {

  if (mode === 'yellow') {

    // Yellow channel: min(R,G) - this represents how much yellow can be produced

    return Math.min(r, g) / 255;

  } else {

    // Standard luminance calculation

    return (0.299*r + 0.587*g + 0.114*b) / 255;

  }

}



// Load file (image or GIF), fill W/H auto, decode all GIF frames using omggif.

document.getElementById('imgLoader').onchange = function(e) {

  let file = e.target.files[0];

  if (!file) return;

  const url = URL.createObjectURL(file);

  const ext = file.name.split('.').pop().toLowerCase();



  if (ext === 'gif') {

    // Load as arraybuffer for omggif

    let reader = new FileReader();

    reader.onload = function(evt) {

      let buffer = evt.target.result;

      try {

        let gif = new GifReader(new Uint8Array(buffer));

        let w = gif.width, h = gif.height, n = gif.numFrames();

        frames = [];

        // Compose a canvas for GIF compositing (GIF frames may be partial/offset)

        let can = document.createElement('canvas');

        can.width = w; can.height = h;

        let cctx = can.getContext('2d');

        cctx.clearRect(0,0,w,h);

        for (let i=0;i<n;++i) {

          let frameImage = cctx.getImageData(0,0,w,h);

          gif.decodeAndBlitFrameRGBA(i, frameImage.data);

          cctx.putImageData(frameImage, 0, 0);

          let copy = cctx.getImageData(0,0,w,h);

          frames.push({img:copy, dur:gif.frameInfo(i).delay*10});

        }

        curFrame = 0;

        document.getElementById('oledW').value = w;

        document.getElementById('oledH').value = h;

        outW = w; outH = h;

        canvas.width = outW; canvas.height = outH;

        showFrameSel();

        previewFrame();

      } catch (exg) {

        alert("GIF file decode error.");

      }

    };

    reader.readAsArrayBuffer(file);

    return;

  }



  // Non-GIF images: load first frame only ("animation" not supported)

  let img = new window.Image();

  img.onload = ()=> {

    frames = [{img:img, dur:0}]; 

    curFrame=0;

    document.getElementById('oledW').value = img.width;

    document.getElementById('oledH').value = img.height;

    outW = img.width;

    outH = img.height;

    canvas.width = outW; canvas.height = outH;

    showFrameSel();

    previewFrame();

  };

  img.src=url;

}



window.previewFrame = function() {

  ctx.fillStyle="#222"; ctx.fillRect(0,0,canvas.width,canvas.height);

  if (!frames.length) return;

  let g = document.getElementById('gamma').value/100;

  let mode = document.getElementById('grayscaleMode').value;

  let frame = frames[curFrame], img = frame.img, isData = (img instanceof ImageData);



  let tmpC = document.createElement('canvas');

  tmpC.width = outW; tmpC.height= outH;

  let tctx = tmpC.getContext('2d');

  if (isData) {

    tctx.putImageData(img,0,0);

    if (img.width!==outW || img.height!==outH)

      tctx.drawImage(tmpC, 0,0,img.width,img.height,0,0,outW,outH); // rescale

  } else {

    tctx.drawImage(img, 0,0, img.width, img.height, 0,0,outW,outH);

  }

  let idat = tctx.getImageData(0,0,outW,outH);

  let d = idat.data;

  let oimg = ctx.getImageData(0,0,outW,outH);

  let odata = oimg.data;

  for(let i=0; i<outW*outH; ++i) {

    let r=d[i*4],g_=d[i*4+1],b=d[i*4+2],a=d[i*4+3];

    let y = calculateGrayscale(r, g_, b, mode);

    y = Math.pow(y, g);

    let gray = Math.round(y*15);

    let px = Math.round(gray*255/15);

    px = a<128 ? 34 : px;

    // Yellow OLED preview! (pure yellow)

    odata[i*4+0]=px; // Red

    odata[i*4+1]=px; // Green

    odata[i*4+2]=0;  // Blue

    odata[i*4+3]=255;

  }

  ctx.putImageData(oimg,0,0);

}



document.getElementById('toCbtn').onclick = function() {

  if (!frames.length) { alert("No image loaded."); return; }

  let nFrames = frames.length;

  let arrname = document.getElementById('cVarName').value.replace(/[^a-zA-Z0-9_]/g,'_') || "oled_img";

  let W = parseInt(document.getElementById('oledW').value|0);

  let H = parseInt(document.getElementById('oledH').value|0);

  let gamma = document.getElementById('gamma').value/100;

  let mode = document.getElementById('grayscaleMode').value;



  let c = '';

  c+= `// SSD1327 4bpp (16 grayscale) export\n`;

  c+= `// size: ${W}x${H}${nFrames>1?`, frames:${nFrames}`:''}\n`;

  c+= `// grayscale mode: ${mode === 'yellow' ? 'yellow channel (min(R,G))' : 'standard luminance'}\n`;

  //c+= `#define IMG_WIDTH  ${W}\n#define IMG_HEIGHT ${H}\n`;



  if(nFrames>1)

    c+= `const uint8_t ${arrname}[${nFrames}][${H}][${Math.ceil(W/2)}] = {\n`;

  else

    c+= `const uint8_t ${arrname}[${H}][${Math.ceil(W/2)}] = {\n`;



  for(let f=0;f<nFrames;++f){

    if (nFrames>1) c+=`  {\n`;

    let img = frames[f].img, isData = (img instanceof ImageData);



    // Get bitmap at expected size

    let tmpC = document.createElement('canvas');

    tmpC.width=W;tmpC.height=H;

    let tctx = tmpC.getContext('2d');

    if (isData) {

      tctx.putImageData(img,0,0);

      if (img.width!==W || img.height!==H)

        tctx.drawImage(tmpC, 0,0,img.width,img.height,0,0,W,H);

    } else {

      tctx.drawImage(img,0,0,img.width,img.height,0,0,W,H);

    }

    let idat = tctx.getImageData(0,0,W,H).data;

    for(let y=0;y<H;++y) {

      c += "    {";

      for (let x=0;x<W;x+=2) {

        let i1 = (y*W + x)*4;

        let i2 = (y*W + x+1)*4;

        function getGray(i) {

          let r=idat[i],g_=idat[i+1],b=idat[i+2],a=idat[i+3];

          let yy = calculateGrayscale(r, g_, b, mode);

          yy=Math.pow(yy,gamma);

          let g4 = Math.round(yy*15);

          return a<128?0:g4;

        }

        let g1 = getGray(i1);

        let g2 = (x+1<W)?getGray(i2):0;

        let packed = (g1<<4)|g2;

        c+="0x"+packed.toString(16).padStart(2,'0');

        if (x+2<W) c+=",";

      }

      c+="}";

      if (y+1<H) c+=",";

      c+="\n";

    }

    if (nFrames>1) c+="  }"+(f+1<nFrames?",\n":"\n");

  }

  c+="};\n";

  c+= `// ${nFrames>1?"[frame][row][col/2]":"[row][col/2]"}, unpack 2 px/byte: hi nibble=left, lo=right, grayscale 0..15\n`;

  document.getElementById('cout').value = c;

};

</script>

</body>

</html>