<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Font to C Array for SSD1327 OLED</title>
<style>
body { font-family:sans-serif; background:#222; color:#eee; }
h1 { font-size:1.4em; }
label { display:inline-block; width:8em; }
input[type=range] {width:5em;}
#oledPreview { background:#222; border:2px solid #111; }
textarea { width:99%; height:12em; font-family:monospace; }
.tiny { font-size:0.7em; opacity:0.7;}
#fontloader { width:10em; }
</style>
</head>
<body>
<h1>Font to C Array Converter for SSD1327 (4bpp, 16 gray) OLED</h1>

<p>
<label>Upload font:</label>
<input type="file" id="fontloader" accept=".ttf,.otf">
<span class="tiny">(TTF/OTF)</span><br>

<label>Font size:</label>
<input type="number" id="fontsize" value="12" min="6" max="32"> px<br>

<label>Grayscale mode:</label>
<select id="graymode">
    <option value="1">Monochrome</option>
    <option value="4" selected>4-bit (0-15) grayscale</option>
</select>
</p>

<p>
<label>Text to preview:</label>
<input type="text" id="sampletext" value="Hello, 世界!"><br>
<label>OLED:</label>
<canvas id="oledPreview" width="128" height="128"></canvas>
</p>
<p class="tiny">Drag mouse to pan preview if text too large.</p>

<button id="gen_c">Generate C Source</button>
<br>
<textarea id="cresult" readonly placeholder="C code output..."></textarea>

<script src="https://cdn.jsdelivr.net/npm/opentype.js@latest/dist/opentype.min.js"></script>
<script>
const ASCII_START = 32, ASCII_END = 126; // 95 chars

let currentFont = null, fontLoaded = false;

// -------- Font file upload --------
document.getElementById('fontloader').addEventListener('change', function(e){
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(event) {
        try {
            currentFont = opentype.parse(event.target.result);
            fontLoaded = true;
            drawPreview();
        } catch (e) {
            alert("Font failed to load.");
            fontLoaded = false;
            currentFont = null;
        }
    };
    reader.readAsArrayBuffer(file);
});

// --------- UI event listeners ---------
document.getElementById('sampletext').addEventListener('input', drawPreview);
document.getElementById('fontsize').addEventListener('input', drawPreview);
document.getElementById('graymode').addEventListener('change', drawPreview);

// ---------- Preview rendering --------
let previewOffsetX = 0, previewOffsetY = 0, isDragging = false, lastMouse = null;
const oledCanvas = document.getElementById('oledPreview');
const ctx = oledCanvas.getContext('2d');

oledCanvas.addEventListener('mousedown', e => {
    isDragging = true;
    lastMouse = {x: e.offsetX, y: e.offsetY};
});
oledCanvas.addEventListener('mouseup',   _ => isDragging = false );
oledCanvas.addEventListener('mouseleave', _ => isDragging = false );
oledCanvas.addEventListener('mousemove',  e => {
    if (isDragging) {
        previewOffsetX += e.offsetX - lastMouse.x;
        previewOffsetY += e.offsetY - lastMouse.y;
        lastMouse = {x: e.offsetX, y: e.offsetY};
        drawPreview();
    }
});

function drawPreview() {
    // Fill background
    ctx.fillStyle = "#222";
    ctx.fillRect(0,0,oledCanvas.width,oledCanvas.height);

    if (!fontLoaded) {
        ctx.fillStyle="#7f7";
        ctx.font = "10px monospace";
        ctx.fillText("Upload a TTF/OTF font", 6, 32);
        return;
    }

    const fontSize = parseInt(document.getElementById('fontsize').value);
    const graymode = document.getElementById('graymode').value;
    const grayscale_levels = graymode == 1 ? 2 : 16;
    let text = document.getElementById('sampletext').value;

    // --- Render on temp canvas for grayscale sampling ---
    // We render at double scale for better AA
    const scale = 2;
    let tmp = document.createElement('canvas');
    tmp.width = oledCanvas.width*scale;
    tmp.height= oledCanvas.height*scale;
    let tctx = tmp.getContext('2d');
    tctx.clearRect(0,0,tmp.width,tmp.height);

    let font = currentFont, ypos = fontSize*scale;

    // Draw string in black on white bg for mask
    tctx.save();
    tctx.fillStyle = "#fff";
    tctx.fillRect(0,0,tmp.width,tmp.height);
    tctx.fillStyle = "#000";
    // Compose OpenType path, allows .draw on canvas:
    let fontPath = font.getPath(
        text,
        previewOffsetX*scale+2,
        previewOffsetY*scale + fontSize*scale,
        fontSize*scale
    );
    fontPath.draw(tctx);
    tctx.restore();
    // Read grayscale back - convert to OLED simulation

    let imgDat = tctx.getImageData(0,0,oledCanvas.width*scale,oledCanvas.height*scale);
    let data = imgDat.data;

    // Compose OLED grayscale output (simulate 4-bit 16 levels)
    let oled = ctx.getImageData(0,0,oledCanvas.width,oledCanvas.height);
    let od = oled.data;

    for(let y=0; y<oledCanvas.height; ++y) for(let x=0; x<oledCanvas.width; ++x) {
        let gsum = 0;
        for(let yy=0; yy<scale; ++yy) for(let xx=0; xx<scale; ++xx) {
            let idx = ((y*scale+yy)*tmp.width + (x*scale+xx)) * 4;
            // Read from tmp: invert, so black char => high value
            let lum = 255 - data[idx]; // grayscale: only red channel needed here
            gsum += lum;
        }
        // average
        let g = gsum/(scale*scale*255);
        if (graymode == 1)         g = g > 0.5 ? 1 : 0;
        else /*16-level*/          g = Math.round(g * 15);

        // Compose RGBA for screen
        let val = Math.round(g * 255/15);
        if (graymode == 1) val = g ? 255 : 0;
        let oidx = (y*oledCanvas.width + x)*4;
        od[oidx+0] = od[oidx+1] = od[oidx+2] = val;
        od[oidx+3] = 255;
    }
    ctx.putImageData(oled,0,0);
}

// ------ C code export -------
document.getElementById('gen_c').onclick = function() {
    if (!fontLoaded) {
        alert("Please upload a font.");
        return;
    }
    let font = currentFont;
    let fontSize = parseInt(document.getElementById('fontsize').value);
    let graymode = document.getElementById('graymode').value;
    let glyph_h = fontSize;
    let glyph_w = Math.ceil(font.getAdvanceWidth('W', fontSize));
    // However, really should raster based on glyph bbox.
    // For now, we use fixed width per char for simplicity.

    // For each ASCII char, raster into a 2D array, collect 4bpp data.
    let result = "// Font generated for SSD1327 OLED\n";
    result += `// Source TTF: ${font.names.fullName.en}\n`;
    result += `#define FONT_ASCII_START ${ASCII_START}\n`;
    result += `#define FONT_WIDTH  ${glyph_w}\n`;
    result += `#define FONT_HEIGHT ${glyph_h}\n`;
    if (graymode==1)
        result += "// Format: [char][row]: 0=bg, 1=fg\n";
    else
        result += "// Format: [char][row][col/2]: 4bpp: high nibble=left px, low nibble=right px\n";

    result += "const uint8_t font_table[][" + glyph_h +
        "][" + Math.ceil(glyph_w/2) + "] = {\n";

    // One temp canvas per char
    for (let ch=ASCII_START; ch<=ASCII_END; ++ch) {
        // temp
        let tc = document.createElement('canvas');
        tc.width = glyph_w;
        tc.height= glyph_h;
        let tctx = tc.getContext('2d');
        tctx.clearRect(0,0,tc.width,tc.height);
        // White bg, black char
        tctx.fillStyle = "#fff";
        tctx.fillRect(0,0,tc.width,tc.height);
        tctx.fillStyle="#000";
        tctx.textBaseline='top';
        let glyph = font.charToGlyph(String.fromCharCode(ch));
        // Centering
        let xoff = 0, yoff = 0;
        // Use OpenType.js to get correct x offset (bearing)
        let xShift = -glyph.getMetrics().leftSideBearing/1000*font.unitsPerEm*fontSize/ font.unitsPerEm;
        // Hack: if glyph not fit, use 0

        glyph.draw(tctx, xoff + xShift, yoff, fontSize);

        // Extract grayscale to 4-bit image
        let im = tctx.getImageData(0,0,glyph_w,glyph_h);
        let d = im.data;
        result += "  { // '" + (String.fromCharCode(ch)=="'"?"\\'":String.fromCharCode(ch)) + "'\n";
        for (let row=0; row<glyph_h; ++row) {
            result += "    {";
            for (let col=0; col<glyph_w; col+=2) {
                // For each pair of pixels, pack to nibble
                let p1i = (row*glyph_w + col) * 4;
                let p2i = (row*glyph_w + col + 1) * 4;
                // Luminance: 0 = bg(white), 1 = fg(black).
                let lum1 = 255-d[p1i];     // black pixel = 255
                let g1 = (graymode==1) ? (lum1>128?1:0) : Math.round(15*lum1/255);
                let g2 = 0;
                if (col+1<glyph_w) {
                    let lum2 = 255-d[p2i];
                    g2 = (graymode==1) ? (lum2>128?1:0) : Math.round(15*lum2/255);
                }
                let packed = (g1<<4) | g2;
                result+="0x"+packed.toString(16).padStart(2,'0');
                if (col+2<glyph_w) result+=",";
            }
            result += "}";
            if (row+1<glyph_h) result+=",";
            result += "\n";
        }
        result += "  }";
        if (ch<ASCII_END) result += ",";
        result += "\n";
    }
    result += "};\n";
    result += `// font_table[char][row][col/2], for '${String.fromCharCode(ASCII_START)}'..'${String.fromCharCode(ASCII_END)}'\n`;

    document.getElementById('cresult').value = result;
}
drawPreview(); // initial

</script>
</body>
</html>